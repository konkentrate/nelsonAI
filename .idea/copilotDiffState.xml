<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/bot/agent.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bot/agent.py" />
              <option name="originalContent" value="import os&#10;import json&#10;import discord&#10;from discord.ext import commands&#10;import httpx&#10;import time&#10;import asyncio&#10;from dotenv import load_dotenv&#10;from memory import ConversationMemory&#10;import sqlite3&#10;&#10;load_dotenv()&#10;&#10;DISCORD_TOKEN = os.getenv(&quot;DISCORD_TOKEN&quot;)&#10;MISTRAL_API_KEY = os.getenv(&quot;MISTRAL_API_KEY&quot;)&#10;ALLOWED_CHANNEL_ID = int(os.getenv(&quot;ALLOWED_CHANNEL_ID&quot;))&#10;&#10;# Define the agent ID to use or fallback to model name if not specified&#10;MISTRAL_AGENT_ID = os.getenv(&quot;MISTRAL_AGENT_ID&quot;)&#10;MISTRAL_MODEL = os.getenv(&quot;MISTRAL_MODEL&quot;, &quot;mistral-small&quot;)&#10;&#10;intents = discord.Intents.default()&#10;intents.message_content = True&#10;&#10;bot = commands.Bot(command_prefix=&quot;/&quot;, intents=intents)&#10;&#10;# Dictionary to store conversation IDs for each user&#10;user_conversations = {}&#10;&#10;# Initialize memory system for stats only&#10;memory = ConversationMemory()&#10;print(&quot;[DEBUG] Memory system initialized (used for stats only)&quot;)&#10;&#10;async def create_conversation():&#10;    &quot;&quot;&quot;Create a new conversation with Mistral Conversations API&quot;&quot;&quot;&#10;    print(&quot;[DEBUG] Creating new Mistral conversation&quot;)&#10;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {MISTRAL_API_KEY}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;    }&#10;&#10;    # Create payload with either agent_id or model as required by the API&#10;    payload = {}&#10;    if MISTRAL_AGENT_ID:&#10;        payload[&quot;agent_id&quot;] = MISTRAL_AGENT_ID&#10;        print(f&quot;[DEBUG] Using agent_id: {MISTRAL_AGENT_ID}&quot;)&#10;    else:&#10;        payload[&quot;model&quot;] = MISTRAL_MODEL&#10;        print(f&quot;[DEBUG] Using model: {MISTRAL_MODEL}&quot;)&#10;&#10;    async with httpx.AsyncClient() as client:&#10;        try:&#10;            response = await client.post(&#10;                &quot;https://api.mistral.ai/v1/conversations&quot;,&#10;                json=payload,&#10;                headers=headers&#10;            )&#10;            response.raise_for_status()&#10;            data = response.json()&#10;            conversation_id = data[&quot;id&quot;]&#10;            print(f&quot;[DEBUG] Created new conversation with ID: {conversation_id}&quot;)&#10;            return conversation_id&#10;        except Exception as e:&#10;            print(f&quot;[DEBUG] Error creating conversation: {str(e)}&quot;)&#10;            if hasattr(e, &quot;response&quot;) and e.response:&#10;                print(f&quot;[DEBUG] Response: {e.response.text}&quot;)&#10;            raise&#10;&#10;async def append_to_conversation(conversation_id, content, role=&quot;user&quot;):&#10;    &quot;&quot;&quot;Append a message to a conversation&quot;&quot;&quot;&#10;    print(f&quot;[DEBUG] Appending {role} message to conversation {conversation_id}&quot;)&#10;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {MISTRAL_API_KEY}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;    }&#10;&#10;    payload = {&#10;        &quot;messages&quot;: [&#10;            {&#10;                &quot;role&quot;: role,&#10;                &quot;content&quot;: content&#10;            }&#10;        ]&#10;    }&#10;&#10;    async with httpx.AsyncClient() as client:&#10;        try:&#10;            response = await client.post(&#10;                f&quot;https://api.mistral.ai/v1/conversations/{conversation_id}/messages&quot;,&#10;                json=payload,&#10;                headers=headers&#10;            )&#10;            response.raise_for_status()&#10;            return response.json()&#10;        except Exception as e:&#10;            print(f&quot;[DEBUG] Error appending message: {str(e)}&quot;)&#10;            if hasattr(e, &quot;response&quot;) and e.response:&#10;                print(f&quot;[DEBUG] Response: {e.response.text}&quot;)&#10;            raise&#10;&#10;async def generate_agent_response(conversation_id):&#10;    &quot;&quot;&quot;Generate a response from the agent for a conversation&quot;&quot;&quot;&#10;    print(f&quot;[DEBUG] Generating agent response for conversation {conversation_id}&quot;)&#10;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {MISTRAL_API_KEY}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;    }&#10;&#10;    # We'll use the standard conversation completion endpoint since we already&#10;    # specified the agent_id or model during conversation creation&#10;    url = f&quot;https://api.mistral.ai/v1/conversations/{conversation_id}/messages&quot;&#10;    print(f&quot;[DEBUG] Request URL: {url}&quot;)&#10;&#10;    async with httpx.AsyncClient(timeout=60.0) as client:&#10;        try:&#10;            # For simplicity, we'll use a non-streaming approach first&#10;            response = await client.post(&#10;                url,&#10;                headers=headers,&#10;                json={&quot;role&quot;: &quot;assistant&quot;}&#10;            )&#10;            response.raise_for_status()&#10;            data = response.json()&#10;&#10;            # Extract the assistant's response&#10;            if &quot;content&quot; in data:&#10;                content = data[&quot;content&quot;]&#10;                print(f&quot;[DEBUG] Got response: {content[:100]}...&quot;)&#10;                return content&#10;            else:&#10;                print(f&quot;[DEBUG] Unexpected response format: {data}&quot;)&#10;                raise ValueError(&quot;Unexpected response format from Mistral API&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;[DEBUG] Error generating response: {str(e)}&quot;)&#10;            if hasattr(e, &quot;response&quot;) and e.response:&#10;                print(f&quot;[DEBUG] Response: {e.response.text}&quot;)&#10;            raise&#10;&#10;async def get_conversation_messages(conversation_id):&#10;    &quot;&quot;&quot;Get all messages in a conversation&quot;&quot;&quot;&#10;    print(f&quot;[DEBUG] Getting messages for conversation {conversation_id}&quot;)&#10;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {MISTRAL_API_KEY}&quot;&#10;    }&#10;&#10;    async with httpx.AsyncClient() as client:&#10;        response = await client.get(&#10;            f&quot;https://api.mistral.ai/v1/conversations/{conversation_id}/messages&quot;,&#10;            headers=headers&#10;        )&#10;        response.raise_for_status()&#10;        return response.json()[&quot;data&quot;]&#10;&#10;@bot.event&#10;async def on_ready():&#10;    print(f&quot;[READY] Logged in as {bot.user}&quot;)&#10;    channel = bot.get_channel(ALLOWED_CHANNEL_ID)&#10;    if channel:&#10;        await channel.send(&quot;Hello! I am online using Mistral's Conversations and Agents API.&quot;)&#10;&#10;@bot.event&#10;async def on_message(message):&#10;    if message.author.bot or message.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;    await bot.process_commands(message)&#10;&#10;@bot.command(name=&quot;nai&quot;)&#10;async def nai_command(ctx, *, prompt: str = None):&#10;    if ctx.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;&#10;    if not prompt:&#10;        await ctx.send(&quot;⚠️ Please provide a prompt after /nai&quot;)&#10;        return&#10;&#10;    print(f&quot;[DEBUG] Processing /nai command from {ctx.author}: {prompt[:50]}...&quot;)&#10;&#10;    user_id = str(ctx.author.id)&#10;    start_time = time.perf_counter()&#10;&#10;    try:&#10;        # Get or create a conversation for this user&#10;        if user_id not in user_conversations:&#10;            conversation_id = await create_conversation()&#10;            user_conversations[user_id] = conversation_id&#10;&#10;            # Add initial system message to set expectations&#10;            await append_to_conversation(&#10;                conversation_id,&#10;                &quot;&quot;&quot;You're a Discord AI assistant.&#10;- Answer concisely and helpfully&#10;- No prefixes like &quot;Assistant:&quot; in your response&#10;- Be polite and respectful&quot;&quot;&quot;,&#10;                role=&quot;system&quot;&#10;            )&#10;        else:&#10;            conversation_id = user_conversations[user_id]&#10;            print(f&quot;[DEBUG] Using existing conversation with ID: {conversation_id}&quot;)&#10;&#10;        # Format the prompt with user information&#10;        formatted_prompt = f&quot;{ctx.author}: {prompt}&quot;&#10;&#10;        # Add user message to the conversation&#10;        await append_to_conversation(conversation_id, formatted_prompt)&#10;        print(f&quot;[DEBUG] Added user message to conversation&quot;)&#10;&#10;        # Send typing indicator while generating&#10;        async with ctx.typing():&#10;            # Get response from Mistral&#10;            try:&#10;                reply = await generate_agent_response(conversation_id)&#10;                if not reply or not reply.strip():&#10;                    raise ValueError(&quot;Empty response from Mistral&quot;)&#10;&#10;                # Calculate elapsed time&#10;                elapsed_time = (time.perf_counter() - start_time) * 1000&#10;                print(f&quot;[DEBUG] Got response from Mistral (took {elapsed_time:.2f} ms)&quot;)&#10;&#10;                # Send the response&#10;                await ctx.send(reply)&#10;&#10;                # Store in memory for stats purposes&#10;                memory.store_message(prompt, str(ctx.author), role=&quot;user&quot;)&#10;                memory.store_message(reply, str(ctx.me), role=&quot;bot&quot;)&#10;                print(&quot;[DEBUG] Messages stored in memory (for stats only)&quot;)&#10;&#10;            except Exception as e:&#10;                print(f&quot;[DEBUG] Error during response generation: {str(e)}&quot;)&#10;                await ctx.send(&quot;⚠️ Error communicating with Mistral.&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error in nai_command: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ An error occurred while processing the command.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;@bot.command(name=&quot;new&quot;)&#10;async def new_conversation(ctx):&#10;    &quot;&quot;&quot;Start a new conversation, forgetting previous context&quot;&quot;&quot;&#10;    user_id = str(ctx.author.id)&#10;&#10;    try:&#10;        # Create a new conversation&#10;        conversation_id = await create_conversation()&#10;        user_conversations[user_id] = conversation_id&#10;&#10;        # Add initial system message&#10;        await append_to_conversation(&#10;            conversation_id,&#10;            &quot;&quot;&quot;You're a Discord AI assistant.&#10;- Answer concisely and helpfully&#10;- No prefixes like &quot;Assistant:&quot; in your response&#10;- Be polite and respectful&quot;&quot;&quot;,&#10;            role=&quot;system&quot;&#10;        )&#10;&#10;        await ctx.send(&quot;Started a new conversation! Your previous conversation history has been cleared.&quot;)&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error creating new conversation: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ Error creating new conversation.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;@bot.command(name=&quot;history&quot;)&#10;async def history_command(ctx, limit: int = 5):&#10;    &quot;&quot;&quot;Show recent conversation history&quot;&quot;&quot;&#10;    user_id = str(ctx.author.id)&#10;&#10;    if user_id not in user_conversations:&#10;        await ctx.send(&quot;You don't have an active conversation. Start one with `/nai`.&quot;)&#10;        return&#10;&#10;    try:&#10;        conversation_id = user_conversations[user_id]&#10;        messages = await get_conversation_messages(conversation_id)&#10;&#10;        # Filter out system messages and limit the number of messages&#10;        filtered_messages = [msg for msg in messages if msg[&quot;role&quot;] != &quot;system&quot;][:limit]&#10;&#10;        if not filtered_messages:&#10;            await ctx.send(&quot;No messages in the current conversation yet.&quot;)&#10;            return&#10;&#10;        history_text = &quot;**Recent Conversation History:**\n\n&quot;&#10;        for msg in reversed(filtered_messages):  # Show oldest first&#10;            role = &quot;&quot; if msg[&quot;role&quot;] == &quot;assistant&quot; else &quot;&quot;&#10;            history_text += f&quot;{role} **{msg['role']}**: {msg['content'][:200]}&quot;&#10;            if len(msg['content']) &gt; 200:&#10;                history_text += &quot;...&quot;&#10;            history_text += &quot;\n\n&quot;&#10;&#10;        await ctx.send(history_text)&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error retrieving conversation history: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ Error retrieving conversation history.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;@bot.command(name=&quot;stats&quot;)&#10;async def stats_command(ctx):&#10;    &quot;&quot;&quot;Show conversation statistics&quot;&quot;&quot;&#10;    user_id = str(ctx.author.id)&#10;&#10;    stats_text = &quot;**Conversation Stats:**\n&quot;&#10;&#10;    # Get memory statistics&#10;    with sqlite3.connect(memory.db_path) as conn:&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;        total_messages = cursor.fetchone()[0]&#10;&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages WHERE role='user'&quot;)&#10;        user_messages = cursor.fetchone()[0]&#10;&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages WHERE role='bot'&quot;)&#10;        bot_messages = cursor.fetchone()[0]&#10;&#10;    stats_text += f&quot; Total messages in memory: {total_messages}\n&quot;&#10;    stats_text += f&quot; User messages: {user_messages}\n&quot;&#10;    stats_text += f&quot; Bot messages: {bot_messages}\n&quot;&#10;&#10;    # Add conversation status&#10;    if user_id in user_conversations:&#10;        stats_text += f&quot; Active conversation ID: {user_conversations[user_id]}\n&quot;&#10;    else:&#10;        stats_text += &quot; No active conversation\n&quot;&#10;&#10;    stats_text += &quot;\n*Using Mistral's Conversations and Agents API*&quot;&#10;&#10;    await ctx.send(stats_text)&#10;&#10;bot.run(DISCORD_TOKEN)&#10;" />
              <option name="updatedContent" value="import os&#10;import json&#10;import discord&#10;from discord.ext import commands&#10;import httpx&#10;import time&#10;import asyncio&#10;from dotenv import load_dotenv&#10;from memory import ConversationMemory&#10;import sqlite3&#10;&#10;load_dotenv()&#10;&#10;DISCORD_TOKEN = os.getenv(&quot;DISCORD_TOKEN&quot;)&#10;MISTRAL_API_KEY = os.getenv(&quot;MISTRAL_API_KEY&quot;)&#10;ALLOWED_CHANNEL_ID = int(os.getenv(&quot;ALLOWED_CHANNEL_ID&quot;))&#10;&#10;# Define the agent ID to use or fallback to model name if not specified&#10;MISTRAL_AGENT_ID = os.getenv(&quot;MISTRAL_AGENT_ID&quot;)&#10;MISTRAL_MODEL = os.getenv(&quot;MISTRAL_MODEL&quot;, &quot;mistral-small&quot;)&#10;&#10;intents = discord.Intents.default()&#10;intents.message_content = True&#10;&#10;bot = commands.Bot(command_prefix=&quot;/&quot;, intents=intents)&#10;&#10;# Dictionary to store conversation IDs for each user&#10;user_conversations = {}&#10;&#10;# Initialize memory system for stats only&#10;memory = ConversationMemory()&#10;print(&quot;[DEBUG] Memory system initialized (used for stats only)&quot;)&#10;&#10;async def create_conversation():&#10;    &quot;&quot;&quot;Create a new conversation with Mistral Conversations API&quot;&quot;&quot;&#10;    print(&quot;[DEBUG] Creating new Mistral conversation&quot;)&#10;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {MISTRAL_API_KEY}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;    }&#10;    &#10;    # Based on the error message, we need to structure the payload differently&#10;    # The API expects either:&#10;    # 1. For agent: {&quot;agent_id&quot;: &quot;agent_id&quot;, &quot;inputs&quot;: {...}}&#10;    # 2. For model: {&quot;model&quot;: &quot;model_name&quot;, &quot;inputs&quot;: {...}}&#10;    &#10;    payload = {&quot;inputs&quot;: {}}  # Empty inputs for now&#10;    &#10;    if MISTRAL_AGENT_ID:&#10;        payload[&quot;agent_id&quot;] = MISTRAL_AGENT_ID&#10;        print(f&quot;[DEBUG] Using agent_id: {MISTRAL_AGENT_ID}&quot;)&#10;    else:&#10;        payload[&quot;model&quot;] = MISTRAL_MODEL&#10;        print(f&quot;[DEBUG] Using model: {MISTRAL_MODEL}&quot;)&#10;    &#10;    print(f&quot;[DEBUG] Conversation payload: {payload}&quot;)&#10;&#10;    # Let's try using the chat completions API instead for compatibility&#10;    try:&#10;        print(&quot;[DEBUG] Creating conversation using chat completions API&quot;)&#10;        async with httpx.AsyncClient() as client:&#10;            response = await client.post(&#10;                &quot;https://api.mistral.ai/v1/chat/completions&quot;,&#10;                json={&#10;                    &quot;model&quot;: MISTRAL_MODEL,&#10;                    &quot;messages&quot;: [&#10;                        {&#10;                            &quot;role&quot;: &quot;system&quot;,&#10;                            &quot;content&quot;: &quot;You're a Discord AI assistant. Answer concisely and helpfully. No prefixes like 'Assistant:' in your response. Be polite and respectful.&quot;&#10;                        }&#10;                    ]&#10;                },&#10;                headers=headers&#10;            )&#10;            response.raise_for_status()&#10;            &#10;            # Generate a unique ID for the conversation&#10;            conversation_id = f&quot;local_{time.time()}&quot;&#10;            print(f&quot;[DEBUG] Created local conversation with ID: {conversation_id}&quot;)&#10;            &#10;            # Store initial system message in memory&#10;            return conversation_id&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error creating conversation using chat API: {str(e)}&quot;)&#10;        if hasattr(e, &quot;response&quot;) and e.response:&#10;            print(f&quot;[DEBUG] Response: {e.response.text}&quot;)&#10;        raise&#10;&#10;async def append_to_conversation(conversation_id, content, role=&quot;user&quot;):&#10;    &quot;&quot;&quot;Store a message in the conversation history&quot;&quot;&quot;&#10;    print(f&quot;[DEBUG] Appending {role} message to conversation {conversation_id}&quot;)&#10;    &#10;    # Store message in the memory system&#10;    memory.store_message(content, &quot;User&quot; if role == &quot;user&quot; else &quot;Assistant&quot;, role=role)&#10;    return {&quot;success&quot;: True}&#10;&#10;async def generate_agent_response(conversation_id, user_message):&#10;    &quot;&quot;&quot;Generate a response using the Mistral chat completions API&quot;&quot;&quot;&#10;    print(f&quot;[DEBUG] Generating response for conversation {conversation_id}&quot;)&#10;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {MISTRAL_API_KEY}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;    }&#10;&#10;    # Get recent messages from memory to build context&#10;    recent_messages = memory.get_recent_messages(15)&#10;    &#10;    # Format messages for the Mistral API&#10;    messages = [&#10;        {&#10;            &quot;role&quot;: &quot;system&quot;,&#10;            &quot;content&quot;: &quot;You're a Discord AI assistant. Answer concisely and helpfully. No prefixes like 'Assistant:' in your response. Be polite and respectful.&quot;&#10;        }&#10;    ]&#10;    &#10;    # Add recent messages to provide context&#10;    for msg in recent_messages:&#10;        role = &quot;assistant&quot; if msg[&quot;role&quot;] == &quot;bot&quot; else &quot;user&quot;&#10;        messages.append({&#10;            &quot;role&quot;: role,&#10;            &quot;content&quot;: msg[&quot;content&quot;]&#10;        })&#10;    &#10;    # Add the current user message&#10;    messages.append({&#10;        &quot;role&quot;: &quot;user&quot;,&#10;        &quot;content&quot;: user_message&#10;    })&#10;    &#10;    payload = {&#10;        &quot;model&quot;: MISTRAL_MODEL,&#10;        &quot;messages&quot;: messages,&#10;        &quot;temperature&quot;: 0.7&#10;    }&#10;    &#10;    print(f&quot;[DEBUG] Sending {len(messages)} messages to Mistral API&quot;)&#10;&#10;    async with httpx.AsyncClient(timeout=60.0) as client:&#10;        try:&#10;            response = await client.post(&#10;                &quot;https://api.mistral.ai/v1/chat/completions&quot;,&#10;                json=payload,&#10;                headers=headers&#10;            )&#10;            response.raise_for_status()&#10;            data = response.json()&#10;            content = data[&quot;choices&quot;][0][&quot;message&quot;][&quot;content&quot;]&#10;            print(f&quot;[DEBUG] Got response from Mistral: {content[:100]}...&quot;)&#10;            return content&#10;        except Exception as e:&#10;            print(f&quot;[DEBUG] Error generating response: {str(e)}&quot;)&#10;            if hasattr(e, &quot;response&quot;) and e.response:&#10;                print(f&quot;[DEBUG] Response: {e.response.text}&quot;)&#10;            raise&#10;&#10;async def get_conversation_messages(conversation_id, limit=10):&#10;    &quot;&quot;&quot;Get recent messages from memory&quot;&quot;&quot;&#10;    print(f&quot;[DEBUG] Getting messages for conversation {conversation_id}&quot;)&#10;    &#10;    messages = memory.get_recent_messages(limit)&#10;    return [&#10;        {&#10;            &quot;role&quot;: &quot;assistant&quot; if msg[&quot;role&quot;] == &quot;bot&quot; else &quot;user&quot;,&#10;            &quot;content&quot;: msg[&quot;content&quot;]&#10;        }&#10;        for msg in messages&#10;    ]&#10;&#10;@bot.event&#10;async def on_ready():&#10;    print(f&quot;[READY] Logged in as {bot.user}&quot;)&#10;    channel = bot.get_channel(ALLOWED_CHANNEL_ID)&#10;    if channel:&#10;        await channel.send(&quot;Hello! I am online using Mistral's chat completions API.&quot;)&#10;&#10;@bot.event&#10;async def on_message(message):&#10;    if message.author.bot or message.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;    await bot.process_commands(message)&#10;&#10;@bot.command(name=&quot;nai&quot;)&#10;async def nai_command(ctx, *, prompt: str = None):&#10;    if ctx.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;&#10;    if not prompt:&#10;        await ctx.send(&quot;⚠️ Please provide a prompt after /nai&quot;)&#10;        return&#10;&#10;    print(f&quot;[DEBUG] Processing /nai command from {ctx.author}: {prompt[:50]}...&quot;)&#10;&#10;    user_id = str(ctx.author.id)&#10;    start_time = time.perf_counter()&#10;&#10;    try:&#10;        # Get or create a conversation for this user&#10;        if user_id not in user_conversations:&#10;            conversation_id = await create_conversation()&#10;            user_conversations[user_id] = conversation_id&#10;            print(f&quot;[DEBUG] Created new conversation for user {user_id}&quot;)&#10;        else:&#10;            conversation_id = user_conversations[user_id]&#10;            print(f&quot;[DEBUG] Using existing conversation with ID: {conversation_id}&quot;)&#10;&#10;        # Format the prompt with user information&#10;        formatted_prompt = f&quot;{ctx.author}: {prompt}&quot;&#10;&#10;        # Add user message to the conversation&#10;        await append_to_conversation(conversation_id, formatted_prompt, role=&quot;user&quot;)&#10;        print(f&quot;[DEBUG] Added user message to conversation&quot;)&#10;&#10;        # Send typing indicator while generating&#10;        async with ctx.typing():&#10;            # Get response from Mistral&#10;            try:&#10;                reply = await generate_agent_response(conversation_id, formatted_prompt)&#10;                if not reply or not reply.strip():&#10;                    raise ValueError(&quot;Empty response from Mistral&quot;)&#10;&#10;                # Calculate elapsed time&#10;                elapsed_time = (time.perf_counter() - start_time) * 1000&#10;                print(f&quot;[DEBUG] Got response from Mistral (took {elapsed_time:.2f} ms)&quot;)&#10;&#10;                # Send the response&#10;                await ctx.send(reply)&#10;&#10;                # Store bot response in memory&#10;                await append_to_conversation(conversation_id, reply, role=&quot;bot&quot;)&#10;                print(&quot;[DEBUG] Stored bot response in memory&quot;)&#10;&#10;            except Exception as e:&#10;                print(f&quot;[DEBUG] Error during response generation: {str(e)}&quot;)&#10;                await ctx.send(&quot;⚠️ Error communicating with Mistral.&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error in nai_command: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ An error occurred while processing the command.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;@bot.command(name=&quot;new&quot;)&#10;async def new_conversation(ctx):&#10;    &quot;&quot;&quot;Start a new conversation, forgetting previous context&quot;&quot;&quot;&#10;    user_id = str(ctx.author.id)&#10;&#10;    try:&#10;        # Create a new conversation&#10;        conversation_id = await create_conversation()&#10;        user_conversations[user_id] = conversation_id&#10;&#10;        # Add initial system message for stats display&#10;        await append_to_conversation(&#10;            conversation_id,&#10;            &quot;&quot;&quot;You're a Discord AI assistant.&#10;- Answer concisely and helpfully&#10;- No prefixes like &quot;Assistant:&quot; in your response&#10;- Be polite and respectful&quot;&quot;&quot;,&#10;            role=&quot;system&quot;&#10;        )&#10;&#10;        await ctx.send(&quot;Started a new conversation! Your previous conversation history has been cleared.&quot;)&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error creating new conversation: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ Error creating new conversation.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;@bot.command(name=&quot;history&quot;)&#10;async def history_command(ctx, limit: int = 5):&#10;    &quot;&quot;&quot;Show recent conversation history&quot;&quot;&quot;&#10;    user_id = str(ctx.author.id)&#10;&#10;    if user_id not in user_conversations:&#10;        await ctx.send(&quot;You don't have an active conversation. Start one with `/nai`.&quot;)&#10;        return&#10;&#10;    try:&#10;        conversation_id = user_conversations[user_id]&#10;        messages = await get_conversation_messages(conversation_id, limit)&#10;&#10;        if not messages:&#10;            await ctx.send(&quot;No messages in the current conversation yet.&quot;)&#10;            return&#10;&#10;        history_text = &quot;**Recent Conversation History:**\n\n&quot;&#10;        for msg in messages:  # Messages should already be in correct order&#10;            role = &quot;&quot; if msg[&quot;role&quot;] == &quot;assistant&quot; else &quot;&quot;&#10;            history_text += f&quot;{role} **{msg['role']}**: {msg['content'][:200]}&quot;&#10;            if len(msg['content']) &gt; 200:&#10;                history_text += &quot;...&quot;&#10;            history_text += &quot;\n\n&quot;&#10;&#10;        await ctx.send(history_text)&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error retrieving conversation history: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ Error retrieving conversation history.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;@bot.command(name=&quot;stats&quot;)&#10;async def stats_command(ctx):&#10;    &quot;&quot;&quot;Show conversation statistics&quot;&quot;&quot;&#10;    user_id = str(ctx.author.id)&#10;&#10;    stats_text = &quot;**Conversation Stats:**\n&quot;&#10;&#10;    # Get memory statistics&#10;    with sqlite3.connect(memory.db_path) as conn:&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;        total_messages = cursor.fetchone()[0]&#10;&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages WHERE role='user'&quot;)&#10;        user_messages = cursor.fetchone()[0]&#10;&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages WHERE role='bot'&quot;)&#10;        bot_messages = cursor.fetchone()[0]&#10;&#10;    stats_text += f&quot; Total messages in memory: {total_messages}\n&quot;&#10;    stats_text += f&quot; User messages: {user_messages}\n&quot;&#10;    stats_text += f&quot; Bot messages: {bot_messages}\n&quot;&#10;&#10;    # Add conversation status&#10;    if user_id in user_conversations:&#10;        stats_text += f&quot; Active conversation ID: {user_conversations[user_id]}\n&quot;&#10;    else:&#10;        stats_text += &quot; No active conversation\n&quot;&#10;&#10;    stats_text += &quot;\n*Using Mistral's chat completions API with memory*&quot;&#10;&#10;    await ctx.send(stats_text)&#10;&#10;bot.run(DISCORD_TOKEN)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bot/bot.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bot/bot.py" />
              <option name="originalContent" value="import os&#10;import json&#10;import discord&#10;from discord.ext import commands&#10;import httpx&#10;&#10;from memory import ConversationMemory&#10;from config import DISCORD_TOKEN, ALLOWED_CHANNEL_ID&#10;from mistral import call_mistral&#10;from prompt import build_prompt  # &lt;-- import the prompt builder&#10;&#10;intents = discord.Intents.default()&#10;intents.message_content = True&#10;&#10;bot = commands.Bot(command_prefix=&quot;/&quot;, intents=intents)&#10;&#10;# Initialize memory system once&#10;memory = ConversationMemory()&#10;print(&quot;[DEBUG] Bot memory system initialized&quot;)&#10;&#10;@bot.event&#10;async def on_ready():&#10;    print(f&quot;[READY] Logged in as {bot.user}&quot;)&#10;    channel = bot.get_channel(ALLOWED_CHANNEL_ID)&#10;    if channel:&#10;        await channel.send(&quot;Hello! I am online.&quot;)&#10;&#10;@bot.event&#10;async def on_message(message):&#10;    if message.author.bot or message.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;    await bot.process_commands(message)&#10;&#10;@bot.command(name=&quot;nai&quot;)&#10;async def nai_command(ctx, *, prompt: str = None):&#10;    if ctx.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;    if not prompt:&#10;        await ctx.send(&quot;⚠️ Please provide a prompt after /nai&quot;)&#10;        return&#10;    print(f&quot;[DEBUG] Processing /nai command from {ctx.author}: {prompt}&quot;)&#10;    try:&#10;        # Get similar messages for context&#10;        similar_messages = memory.search_similar_messages(prompt, ignore_bot=False)&#10;        print(f&quot;[DEBUG] Found {len(similar_messages)} similar messages&quot;)&#10;        # Get recent messages for additional context&#10;        recent_messages = memory.get_recent_messages(10)&#10;        print(f&quot;[DEBUG] Retrieved {len(recent_messages)} recent messages&quot;)&#10;        # Build prompt using prompt builder&#10;        full_prompt = build_prompt(prompt, recent_messages, similar_messages, ctx.author)&#10;        reply = None&#10;        async with ctx.channel.typing():&#10;            try:&#10;                reply = await call_mistral(full_prompt)&#10;                if not reply.strip():&#10;                    raise ValueError(&quot;Empty response from Mistral&quot;)&#10;                print(&quot;[DEBUG] Got response from Mistral&quot;)&#10;                await ctx.send(reply)&#10;            except Exception as e:&#10;                await ctx.send(&quot;⚠️ Error communicating with Mistral.&quot;)&#10;                print(f&quot;[DEBUG] Error calling Mistral: {str(e)}&quot;)&#10;&#10;        # Store messages in memory after sending the response&#10;        memory.store_message(prompt, str(ctx.author), role=&quot;user&quot;)&#10;        print(&quot;[DEBUG] User message stored in memory&quot;)&#10;&#10;        if reply:&#10;            memory.store_message(reply, str(ctx.me), role=&quot;bot&quot;)&#10;            print(&quot;[DEBUG] Bot reply stored in memory&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error in nai_command: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ An error occurred while processing the command.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;bot.run(DISCORD_TOKEN)&#10;" />
              <option name="updatedContent" value="import os&#10;import json&#10;import discord&#10;from discord.ext import commands&#10;import httpx&#10;&#10;from memory import ConversationMemory&#10;from config import DISCORD_TOKEN, ALLOWED_CHANNEL_ID&#10;from mistral import call_mistral&#10;from prompt import build_prompt  # &lt;-- import the prompt builder&#10;&#10;intents = discord.Intents.default()&#10;intents.message_content = True&#10;&#10;bot = commands.Bot(command_prefix=&quot;/&quot;, intents=intents)&#10;&#10;# Initialize memory system once&#10;memory = ConversationMemory()&#10;print(&quot;[DEBUG] Bot memory system initialized&quot;)&#10;&#10;@bot.event&#10;async def on_ready():&#10;    print(f&quot;[READY] Logged in as {bot.user}&quot;)&#10;    channel = bot.get_channel(ALLOWED_CHANNEL_ID)&#10;    if channel:&#10;        await channel.send(&quot;Hello! I am online.&quot;)&#10;&#10;@bot.event&#10;async def on_message(message):&#10;    if message.author.bot or message.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;    await bot.process_commands(message)&#10;&#10;@bot.command(name=&quot;nai&quot;)&#10;async def nai_command(ctx, *, prompt: str = None):&#10;    if ctx.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;    if not prompt:&#10;        await ctx.send(&quot;⚠️ Please provide a prompt after /nai&quot;)&#10;        return&#10;    print(f&quot;[DEBUG] Processing /nai command from {ctx.author}: {prompt}&quot;)&#10;    try:&#10;        # Get similar messages for context&#10;        similar_messages = memory.search_similar_messages(prompt, ignore_bot=False)&#10;        print(f&quot;[DEBUG] Found {len(similar_messages)} similar messages&quot;)&#10;        # Build prompt using prompt builder (no recent messages)&#10;        full_prompt = build_prompt(prompt, similar_messages)&#10;        reply = None&#10;        async with ctx.channel.typing():&#10;            try:&#10;                reply = await call_mistral(full_prompt)&#10;                if not reply.strip():&#10;                    raise ValueError(&quot;Empty response from Mistral&quot;)&#10;                print(&quot;[DEBUG] Got response from Mistral&quot;)&#10;                await ctx.send(reply)&#10;            except Exception as e:&#10;                await ctx.send(&quot;⚠️ Error communicating with Mistral.&quot;)&#10;                print(f&quot;[DEBUG] Error calling Mistral: {str(e)}&quot;)&#10;&#10;        # Store messages in memory after sending the response&#10;        memory.store_message(prompt, str(ctx.author), role=&quot;user&quot;)&#10;        print(&quot;[DEBUG] User message stored in memory&quot;)&#10;&#10;        if reply:&#10;            memory.store_message(reply, str(ctx.me), role=&quot;bot&quot;)&#10;            print(&quot;[DEBUG] Bot reply stored in memory&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error in nai_command: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ An error occurred while processing the command.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;bot.run(DISCORD_TOKEN)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bot/memory.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bot/memory.py" />
              <option name="originalContent" value="import sqlite3&#10;import faiss&#10;import numpy as np&#10;from datetime import datetime&#10;from sentence_transformers import SentenceTransformer&#10;from typing import List, Tuple&#10;import time&#10;&#10;&#10;class ConversationMemory:&#10;    def __init__(self, db_path: str = &quot;conversations.db&quot;):&#10;        print(f&quot;[DEBUG] Initializing ConversationMemory with database: {db_path}&quot;)&#10;        self.db_path = db_path&#10;        self.model = SentenceTransformer('all-MiniLM-L6-v2')&#10;        self.index = None&#10;        self.initialize_db()&#10;        self.load_faiss_index()&#10;&#10;    def initialize_db(self):&#10;        print(&quot;[DEBUG] Initializing SQLite database...&quot;)&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            conn.execute(&quot;&quot;&quot;&#10;                CREATE TABLE IF NOT EXISTS messages&#10;                (id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                 content TEXT NOT NULL,&#10;                 author TEXT NOT NULL,&#10;                 role TEXT NOT NULL DEFAULT 'user',&#10;                 timestamp DATETIME NOT NULL,&#10;                 embedding BLOB)&#10;            &quot;&quot;&quot;)&#10;            conn.commit()&#10;&#10;            # Print schema for confirmation&#10;            cursor = conn.execute(&quot;PRAGMA table_info(messages)&quot;)&#10;            columns = [row[1] for row in cursor.fetchall()]&#10;            print(f&quot;[DEBUG] messages table columns: {columns}&quot;)&#10;&#10;        print(&quot;[DEBUG] Database initialization complete&quot;)&#10;&#10;    def store_message(self, content: str, author: str, role: str = &quot;user&quot;):&#10;        print(f&quot;[DEBUG] Storing message from {author} (role={role}): {content[:50]}...&quot;)&#10;        embedding = self.model.encode([content])[0]&#10;&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            cursor = conn.execute(&#10;                &quot;INSERT INTO messages (content, author, role, timestamp, embedding) VALUES (?, ?, ?, ?, ?)&quot;,&#10;                (content, author, role, datetime.now(), embedding.tobytes())&#10;            )&#10;            message_id = cursor.lastrowid&#10;            conn.commit()&#10;            print(f&quot;[DEBUG] Inserted message with ID: {message_id}&quot;)&#10;&#10;            cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;            count = cursor.fetchone()[0]&#10;            print(f&quot;[DEBUG] Total messages in database: {count}&quot;)&#10;&#10;        if self.index is None:&#10;            print(&quot;[DEBUG] Creating new FAISS index&quot;)&#10;            self.index = faiss.IndexFlatL2(embedding.shape[0])&#10;        self.index.add(embedding.reshape(1, -1))&#10;        print(f&quot;[DEBUG] FAISS index size: {self.index.ntotal}&quot;)&#10;&#10;    def search_similar_messages(self, query: str, k: int = 4, ignore_bot: bool = False) -&gt; List[Tuple[str, float]]:&#10;        print(f&quot;[DEBUG] Searching for messages similar to: {query[:50]}... (ignore_bot={ignore_bot})&quot;)&#10;        query_embedding = self.model.encode([query])[0]&#10;&#10;        if self.index is None or self.index.ntotal == 0:&#10;            print(&quot;[DEBUG] No messages in index to search&quot;)&#10;            return []&#10;&#10;        # Start timing the search&#10;        start_time = time.perf_counter()  # Start timing&#10;&#10;        # Get k+1 results since the query might be in the database&#10;        distances, indices = self.index.search(query_embedding.reshape(1, -1), min(k+1, self.index.ntotal))&#10;&#10;        elapsed = (time.perf_counter() - start_time) * 1000  # ms&#10;        print(f&quot;[DEBUG] FAISS search took {elapsed:.2f} ms&quot;)&#10;        print(f&quot;[DEBUG] FAISS found {len(indices[0])} results with indices: {indices[0]}&quot;)&#10;&#10;        results = []&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            for idx, distance in zip(indices[0], distances[0]):&#10;                if idx == -1:  # FAISS returns -1 for empty slots&#10;                    continue&#10;&#10;                # Fetch message and role&#10;                cursor = conn.execute(&#10;                    &quot;&quot;&quot;&#10;                    SELECT content, author, role, timestamp &#10;                    FROM messages &#10;                    LIMIT 1 OFFSET ?&#10;                    &quot;&quot;&quot;,&#10;                    (int(idx),)&#10;                )&#10;                row = cursor.fetchone()&#10;                if row:&#10;                    content, author, role, timestamp = row&#10;                    if ignore_bot and role == &quot;bot&quot;:&#10;                        continue&#10;                    similarity = 1.0 / (1.0 + float(distance))  # Convert distance to similarity score&#10;                    results.append((f&quot;{author} ({role}, {timestamp}): {content}&quot;, similarity))&#10;                    print(f&quot;[DEBUG] Found message at index {idx} with similarity {similarity:.3f} (role={role})&quot;)&#10;                else:&#10;                    print(f&quot;[DEBUG] No message found at index {idx}&quot;)&#10;&#10;        # Ensure we return only up to `k` results&#10;        results = results[:k]&#10;        print(f&quot;[DEBUG] Returning {len(results)} results&quot;)&#10;        return results&#10;&#10;    def load_faiss_index(self):&#10;        print(&quot;[DEBUG] Loading FAISS index from database...&quot;)&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;            count = cursor.fetchone()[0]&#10;            print(f&quot;[DEBUG] Found {count} messages in database&quot;)&#10;&#10;            cursor = conn.execute(&quot;SELECT embedding FROM messages&quot;)&#10;            embeddings = cursor.fetchall()&#10;&#10;            if embeddings:&#10;                embedding_size = len(np.frombuffer(embeddings[0][0], dtype=np.float32))&#10;                self.index = faiss.IndexFlatL2(embedding_size)&#10;                print(f&quot;[DEBUG] Created FAISS index with dimension {embedding_size}&quot;)&#10;&#10;                all_embeddings = np.vstack([&#10;                    np.frombuffer(emb[0], dtype=np.float32) for emb in embeddings&#10;                ])&#10;                self.index.add(all_embeddings)&#10;                print(f&quot;[DEBUG] Loaded {len(embeddings)} embeddings into FAISS index&quot;)&#10;            else:&#10;                print(&quot;[DEBUG] No existing embeddings found in database&quot;)&#10;&#10;" />
              <option name="updatedContent" value="import sqlite3&#10;import faiss&#10;import numpy as np&#10;from datetime import datetime&#10;from sentence_transformers import SentenceTransformer&#10;from typing import List, Tuple&#10;import time&#10;&#10;&#10;class ConversationMemory:&#10;    def __init__(self, db_path: str = &quot;conversations.db&quot;):&#10;        print(f&quot;[DEBUG] Initializing ConversationMemory with database: {db_path}&quot;)&#10;        self.db_path = db_path&#10;        self.model = SentenceTransformer('all-MiniLM-L6-v2')&#10;        self.index = None&#10;        self.initialize_db()&#10;        self.load_faiss_index()&#10;&#10;    def initialize_db(self):&#10;        print(&quot;[DEBUG] Initializing SQLite database...&quot;)&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            conn.execute(&quot;&quot;&quot;&#10;                CREATE TABLE IF NOT EXISTS messages&#10;                (id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                 content TEXT NOT NULL,&#10;                 author TEXT NOT NULL,&#10;                 role TEXT NOT NULL DEFAULT 'user',&#10;                 timestamp DATETIME NOT NULL,&#10;                 embedding BLOB)&#10;            &quot;&quot;&quot;)&#10;            conn.commit()&#10;&#10;            # Print schema for confirmation&#10;            cursor = conn.execute(&quot;PRAGMA table_info(messages)&quot;)&#10;            columns = [row[1] for row in cursor.fetchall()]&#10;            print(f&quot;[DEBUG] messages table columns: {columns}&quot;)&#10;&#10;        print(&quot;[DEBUG] Database initialization complete&quot;)&#10;&#10;    def store_message(self, content: str, author: str, role: str = &quot;user&quot;):&#10;        print(f&quot;[DEBUG] Storing message from {author} (role={role}): {content[:50]}...&quot;)&#10;        embedding = self.model.encode([content])[0]&#10;&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            cursor = conn.execute(&#10;                &quot;INSERT INTO messages (content, author, role, timestamp, embedding) VALUES (?, ?, ?, ?, ?)&quot;,&#10;                (content, author, role, datetime.now(), embedding.tobytes())&#10;            )&#10;            message_id = cursor.lastrowid&#10;            conn.commit()&#10;            print(f&quot;[DEBUG] Inserted message with ID: {message_id}&quot;)&#10;&#10;            cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;            count = cursor.fetchone()[0]&#10;            print(f&quot;[DEBUG] Total messages in database: {count}&quot;)&#10;&#10;        if self.index is None:&#10;            print(&quot;[DEBUG] Creating new FAISS index&quot;)&#10;            self.index = faiss.IndexFlatL2(embedding.shape[0])&#10;        self.index.add(embedding.reshape(1, -1))&#10;        print(f&quot;[DEBUG] FAISS index size: {self.index.ntotal}&quot;)&#10;&#10;    def search_similar_messages(self, query: str, k: int = 4, ignore_bot: bool = False) -&gt; List[Tuple[str, float]]:&#10;        print(f&quot;[DEBUG] Searching for messages similar to: {query[:50]}...&quot;)&#10;        &#10;        # If index is empty, return empty results&#10;        if self.index is None or self.index.ntotal == 0:&#10;            print(&quot;[DEBUG] No messages in index to search&quot;)&#10;            return []&#10;&#10;        # Encode query to vector&#10;        query_embedding = self.model.encode([query])[0]&#10;        &#10;        # Search similar vectors&#10;        distances, indices = self.index.search(query_embedding.reshape(1, -1), k)&#10;        &#10;        results = []&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            for idx, distance in zip(indices[0], distances[0]):&#10;                if idx == -1:  # Skip invalid indices&#10;                    continue&#10;                    &#10;                cursor = conn.execute(&#10;                    &quot;SELECT content, author FROM messages LIMIT 1 OFFSET ?&quot;,&#10;                    (int(idx),)&#10;                )&#10;                row = cursor.fetchone()&#10;                if row:&#10;                    content, author = row&#10;                    results.append((f&quot;{author}: {content}&quot;, float(distance)))&#10;&#10;        return results&#10;&#10;    def load_faiss_index(self):&#10;        print(&quot;[DEBUG] Loading FAISS index from database...&quot;)&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;            count = cursor.fetchone()[0]&#10;            print(f&quot;[DEBUG] Found {count} messages in database&quot;)&#10;&#10;            cursor = conn.execute(&quot;SELECT embedding FROM messages&quot;)&#10;            embeddings = cursor.fetchall()&#10;&#10;            if embeddings:&#10;                embedding_size = len(np.frombuffer(embeddings[0][0], dtype=np.float32))&#10;                self.index = faiss.IndexFlatL2(embedding_size)&#10;                print(f&quot;[DEBUG] Created FAISS index with dimension {embedding_size}&quot;)&#10;&#10;                all_embeddings = np.vstack([&#10;                    np.frombuffer(emb[0], dtype=np.float32) for emb in embeddings&#10;                ])&#10;                self.index.add(all_embeddings)&#10;                print(f&quot;[DEBUG] Loaded {len(embeddings)} embeddings into FAISS index&quot;)&#10;            else:&#10;                print(&quot;[DEBUG] No existing embeddings found in database&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bot/prompt.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bot/prompt.py" />
              <option name="originalContent" value="def build_prompt(prompt, recent_messages, similar_messages, author):&#10;    out = &quot;&quot;&quot;You're a Discord AI assistant. Answer ONLY the current question below.&#10;&#10;[INSTRUCTIONS]&#10;- Answer only the current question&#10;- Use past messages for context only&#10;- Be concise and helpful&#10;- No prefixes like &quot;Assistant:&quot; in response&#10;&#10;[RELEVANT MESSAGES]&#10;&quot;&quot;&quot;&#10;    for msg, _ in similar_messages:&#10;        out += f&quot;{msg}\n&quot;&#10;&#10;    if recent_messages:&#10;        out += &quot;\n[RECENT MESSAGES]\n&quot;&#10;        for msg in recent_messages:&#10;            out += f&quot;{msg['author']} ({msg['role']}): {msg['content']}\n&quot;&#10;&#10;    out += f&quot;\n[CURRENT QUESTION]\n{author}: {prompt}\n&quot;&#10;    return out" />
              <option name="updatedContent" value="def build_prompt(question, similar_messages):&#10;    retrieved_chunk = &quot;\n&quot;.join([msg for msg, _ in similar_messages])&#10;    prompt = f&quot;&quot;&quot;&#10;Context information is below.&#10;---------------------&#10;{retrieved_chunk}&#10;---------------------&#10;Given the context information and not prior knowledge, answer the query.&#10;Query: {question}&#10;Answer:&#10;&quot;&quot;&quot;&#10;    return prompt" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>