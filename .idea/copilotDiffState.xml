<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/bot/agent.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bot/agent.py" />
              <option name="originalContent" value="import os&#10;import json&#10;import discord&#10;from discord.ext import commands&#10;import httpx&#10;import time&#10;from dotenv import load_dotenv&#10;from memory import ConversationMemory&#10;&#10;load_dotenv()&#10;&#10;DISCORD_TOKEN = os.getenv(&quot;DISCORD_TOKEN&quot;)&#10;MISTRAL_API_KEY = os.getenv(&quot;MISTRAL_API_KEY&quot;)&#10;ALLOWED_CHANNEL_ID = int(os.getenv(&quot;ALLOWED_CHANNEL_ID&quot;))&#10;&#10;intents = discord.Intents.default()&#10;intents.message_content = True&#10;&#10;bot = commands.Bot(command_prefix=&quot;/&quot;, intents=intents)&#10;&#10;# Dictionary to store conversation history for each user&#10;user_conversations = {}&#10;&#10;# Initialize memory system for context search&#10;memory = ConversationMemory()&#10;&#10;async def call_mistral(messages):&#10;    &quot;&quot;&quot;Call Mistral API with conversation messages&quot;&quot;&quot;&#10;    print(f&quot;[DEBUG] Calling Mistral API with {len(messages)} messages&quot;)&#10;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {MISTRAL_API_KEY}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;    }&#10;&#10;    payload = {&#10;        &quot;model&quot;: &quot;mistral-small&quot;,&#10;        &quot;messages&quot;: messages,&#10;        &quot;temperature&quot;: 0.7&#10;    }&#10;&#10;    print(f&quot;[DEBUG] PROMPT TO MISTRAL:\n{json.dumps(messages, indent=2)[:300]}...&quot;)&#10;&#10;    async with httpx.AsyncClient() as client:&#10;        response = await client.post(&#10;            &quot;https://api.mistral.ai/v1/chat/completions&quot;,&#10;            json=payload,&#10;            headers=headers,&#10;            timeout=30&#10;        )&#10;        response.raise_for_status()&#10;        data = response.json()&#10;        content = data[&quot;choices&quot;][0][&quot;message&quot;][&quot;content&quot;]&#10;        return content&#10;&#10;@bot.event&#10;async def on_ready():&#10;    print(f&quot;[READY] Logged in as {bot.user}&quot;)&#10;    channel = bot.get_channel(ALLOWED_CHANNEL_ID)&#10;    if channel:&#10;        await channel.send(&quot;Hello! I am online and using conversation history with context search.&quot;)&#10;&#10;@bot.event&#10;async def on_message(message):&#10;    if message.author.bot or message.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;    await bot.process_commands(message)&#10;&#10;@bot.command(name=&quot;nai&quot;)&#10;async def nai_command(ctx, *, prompt: str = None):&#10;    if ctx.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;&#10;    if not prompt:&#10;        await ctx.send(&quot;⚠️ Please provide a prompt after /nai&quot;)&#10;        return&#10;&#10;    print(f&quot;[DEBUG] Processing /nai command from {ctx.author}: {prompt[:50]}...&quot;)&#10;&#10;    user_id = str(ctx.author.id)&#10;    start_time = time.perf_counter()&#10;&#10;    try:&#10;        # Initialize conversation for this user if it doesn't exist&#10;        if user_id not in user_conversations:&#10;            user_conversations[user_id] = []&#10;&#10;            # Add system message to the conversation&#10;            user_conversations[user_id].append({&#10;                &quot;role&quot;: &quot;system&quot;,&#10;                &quot;content&quot;: &quot;&quot;&quot;You're a Discord AI assistant. &#10;- Answer ONLY the current question&#10;- Be concise and helpful&#10;- No prefixes like &quot;Assistant:&quot; in response&quot;&quot;&quot;&#10;            })&#10;&#10;        # Get conversation history for this user&#10;        conversation = user_conversations[user_id].copy()&#10;&#10;        # Search for similar messages in memory to provide context&#10;        similar_messages = memory.search_similar_messages(prompt, k=4, ignore_bot=False)&#10;        print(f&quot;[DEBUG] Found {len(similar_messages)} similar messages&quot;)&#10;&#10;        # Get recent messages for additional context&#10;        recent_messages = memory.get_recent_messages(5)&#10;        print(f&quot;[DEBUG] Retrieved {len(recent_messages)} recent messages&quot;)&#10;&#10;        # Add context to the conversation&#10;        if similar_messages or recent_messages:&#10;            context_text = &quot;&quot;&#10;&#10;            if similar_messages:&#10;                context_text += &quot;[RELEVANT CONTEXT]\n&quot;&#10;                for msg, similarity in similar_messages:&#10;                    context_text += f&quot;{msg}\n&quot;&#10;&#10;            if recent_messages:&#10;                context_text += &quot;\n[RECENT MESSAGES]\n&quot;&#10;                for msg in recent_messages:&#10;                    context_text += f&quot;{msg['author']} ({msg['role']}): {msg['content']}\n&quot;&#10;&#10;            # Add context as a system message&#10;            conversation.append({&#10;                &quot;role&quot;: &quot;system&quot;,&#10;                &quot;content&quot;: f&quot;Context for your response:\n{context_text}&quot;&#10;            })&#10;&#10;        # Add user message to conversation&#10;        conversation.append({&#10;            &quot;role&quot;: &quot;user&quot;,&#10;            &quot;content&quot;: f&quot;{ctx.author}: {prompt}&quot;&#10;        })&#10;&#10;        # Send typing indicator while processing&#10;        async with ctx.channel.typing():&#10;            # Get response from Mistral&#10;            reply = await call_mistral(conversation)&#10;&#10;            if not reply.strip():&#10;                raise ValueError(&quot;Empty response from Mistral&quot;)&#10;&#10;            # Calculate elapsed time&#10;            elapsed_time = (time.perf_counter() - start_time) * 1000&#10;            print(f&quot;[DEBUG] Got response from Mistral (took {elapsed_time:.2f} ms)&quot;)&#10;&#10;            # Send the response&#10;            await ctx.send(reply)&#10;&#10;            # Add assistant response to conversation history&#10;            user_conversations[user_id].append({&#10;                &quot;role&quot;: &quot;user&quot;,&#10;                &quot;content&quot;: f&quot;{ctx.author}: {prompt}&quot;&#10;            })&#10;            user_conversations[user_id].append({&#10;                &quot;role&quot;: &quot;assistant&quot;,&#10;                &quot;content&quot;: reply&#10;            })&#10;&#10;            # Keep conversation history to a reasonable size (last 10 messages)&#10;            if len(user_conversations[user_id]) &gt; 12:  # system + 10 messages (5 exchanges)&#10;                # Keep the system message and the last 10 messages&#10;                user_conversations[user_id] = [user_conversations[user_id][0]] + user_conversations[user_id][-10:]&#10;&#10;            # Store messages in memory for future context&#10;            memory.store_message(prompt, str(ctx.author), role=&quot;user&quot;)&#10;            memory.store_message(reply, str(ctx.me), role=&quot;bot&quot;)&#10;            print(&quot;[DEBUG] Messages stored in memory&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error in nai_command: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ An error occurred while processing the command.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;# Add a command to create a new conversation&#10;@bot.command(name=&quot;new&quot;)&#10;async def new_conversation(ctx):&#10;    &quot;&quot;&quot;Start a new conversation, forgetting previous context&quot;&quot;&quot;&#10;    user_id = str(ctx.author.id)&#10;&#10;    # Reset conversation for this user&#10;    user_conversations[user_id] = [{&#10;        &quot;role&quot;: &quot;system&quot;,&#10;        &quot;content&quot;: &quot;&quot;&quot;You're a Discord AI assistant. &#10;- Answer ONLY the current question&#10;- Be concise and helpful&#10;- No prefixes like &quot;Assistant:&quot; in response&quot;&quot;&quot;&#10;    }]&#10;&#10;    await ctx.send(&quot;Started a new conversation! Your previous conversation history has been cleared.&quot;)&#10;&#10;@bot.command(name=&quot;stats&quot;)&#10;async def stats_command(ctx):&#10;    &quot;&quot;&quot;Show conversation statistics&quot;&quot;&quot;&#10;    user_id = str(ctx.author.id)&#10;&#10;    stats_text = &quot;**Conversation Stats:**\n&quot;&#10;&#10;    # Get memory statistics&#10;    with sqlite3.connect(memory.db_path) as conn:&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;        total_messages = cursor.fetchone()[0]&#10;&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages WHERE role='user'&quot;)&#10;        user_messages = cursor.fetchone()[0]&#10;&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages WHERE role='bot'&quot;)&#10;        bot_messages = cursor.fetchone()[0]&#10;&#10;    stats_text += f&quot; Total messages in memory: {total_messages}\n&quot;&#10;    stats_text += f&quot; User messages: {user_messages}\n&quot;&#10;    stats_text += f&quot; Bot messages: {bot_messages}\n&quot;&#10;&#10;    # Add conversation history stats&#10;    if user_id in user_conversations:&#10;        conv_len = len(user_conversations[user_id]) - 1  # Don't count system message&#10;        stats_text += f&quot; Your current conversation length: {conv_len} messages\n&quot;&#10;    else:&#10;        stats_text += &quot; No active conversation\n&quot;&#10;&#10;    await ctx.send(stats_text)&#10;&#10;# Import sqlite3 for stats command&#10;import sqlite3&#10;&#10;bot.run(DISCORD_TOKEN)&#10;" />
              <option name="updatedContent" value="import os&#10;import json&#10;import discord&#10;from discord.ext import commands&#10;import httpx&#10;import time&#10;from dotenv import load_dotenv&#10;from memory import ConversationMemory&#10;import sqlite3&#10;&#10;load_dotenv()&#10;&#10;DISCORD_TOKEN = os.getenv(&quot;DISCORD_TOKEN&quot;)&#10;MISTRAL_API_KEY = os.getenv(&quot;MISTRAL_API_KEY&quot;)&#10;ALLOWED_CHANNEL_ID = int(os.getenv(&quot;ALLOWED_CHANNEL_ID&quot;))&#10;&#10;intents = discord.Intents.default()&#10;intents.message_content = True&#10;&#10;bot = commands.Bot(command_prefix=&quot;/&quot;, intents=intents)&#10;&#10;# Dictionary to store conversation history for each user&#10;user_conversations = {}&#10;&#10;# Initialize memory system for context search - still needed for stats&#10;memory = ConversationMemory()&#10;print(&quot;[DEBUG] Memory system initialized but RAG functionality commented out&quot;)&#10;&#10;async def call_mistral(messages):&#10;    &quot;&quot;&quot;Call Mistral API with conversation messages&quot;&quot;&quot;&#10;    print(f&quot;[DEBUG] Calling Mistral API with {len(messages)} messages&quot;)&#10;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {MISTRAL_API_KEY}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;    }&#10;&#10;    payload = {&#10;        &quot;model&quot;: &quot;mistral-small&quot;,&#10;        &quot;messages&quot;: messages,&#10;        &quot;temperature&quot;: 0.7&#10;    }&#10;&#10;    print(f&quot;[DEBUG] PROMPT TO MISTRAL:\n{json.dumps(messages, indent=2)[:300]}...&quot;)&#10;&#10;    async with httpx.AsyncClient() as client:&#10;        response = await client.post(&#10;            &quot;https://api.mistral.ai/v1/chat/completions&quot;,&#10;            json=payload,&#10;            headers=headers,&#10;            timeout=30&#10;        )&#10;        response.raise_for_status()&#10;        data = response.json()&#10;        content = data[&quot;choices&quot;][0][&quot;message&quot;][&quot;content&quot;]&#10;        return content&#10;&#10;@bot.event&#10;async def on_ready():&#10;    print(f&quot;[READY] Logged in as {bot.user}&quot;)&#10;    channel = bot.get_channel(ALLOWED_CHANNEL_ID)&#10;    if channel:&#10;        await channel.send(&quot;Hello! I am online with conversation history only (RAG disabled).&quot;)&#10;&#10;@bot.event&#10;async def on_message(message):&#10;    if message.author.bot or message.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;    await bot.process_commands(message)&#10;&#10;@bot.command(name=&quot;nai&quot;)&#10;async def nai_command(ctx, *, prompt: str = None):&#10;    if ctx.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;&#10;    if not prompt:&#10;        await ctx.send(&quot;⚠️ Please provide a prompt after /nai&quot;)&#10;        return&#10;&#10;    print(f&quot;[DEBUG] Processing /nai command from {ctx.author}: {prompt[:50]}...&quot;)&#10;&#10;    user_id = str(ctx.author.id)&#10;    start_time = time.perf_counter()&#10;&#10;    try:&#10;        # Initialize conversation for this user if it doesn't exist&#10;        if user_id not in user_conversations:&#10;            user_conversations[user_id] = []&#10;&#10;            # Add system message to the conversation&#10;            user_conversations[user_id].append({&#10;                &quot;role&quot;: &quot;system&quot;,&#10;                &quot;content&quot;: &quot;&quot;&quot;You're a Discord AI assistant. &#10;- Answer ONLY the current question&#10;- Be concise and helpful&#10;- No prefixes like &quot;Assistant:&quot; in response&quot;&quot;&quot;&#10;            })&#10;&#10;        # Get conversation history for this user&#10;        conversation = user_conversations[user_id].copy()&#10;&#10;        # RAG functionality commented out&#10;        &quot;&quot;&quot;&#10;        # Search for similar messages in memory to provide context&#10;        similar_messages = memory.search_similar_messages(prompt, k=4, ignore_bot=False)&#10;        print(f&quot;[DEBUG] Found {len(similar_messages)} similar messages&quot;)&#10;&#10;        # Get recent messages for additional context&#10;        recent_messages = memory.get_recent_messages(5)&#10;        print(f&quot;[DEBUG] Retrieved {len(recent_messages)} recent messages&quot;)&#10;&#10;        # Add context to the conversation&#10;        if similar_messages or recent_messages:&#10;            context_text = &quot;&quot;&#10;&#10;            if similar_messages:&#10;                context_text += &quot;[RELEVANT CONTEXT]\n&quot;&#10;                for msg, similarity in similar_messages:&#10;                    context_text += f&quot;{msg}\n&quot;&#10;&#10;            if recent_messages:&#10;                context_text += &quot;\n[RECENT MESSAGES]\n&quot;&#10;                for msg in recent_messages:&#10;                    context_text += f&quot;{msg['author']} ({msg['role']}): {msg['content']}\n&quot;&#10;&#10;            # Add context as a system message&#10;            conversation.append({&#10;                &quot;role&quot;: &quot;system&quot;,&#10;                &quot;content&quot;: f&quot;Context for your response:\n{context_text}&quot;&#10;            })&#10;        &quot;&quot;&quot;&#10;        print(&quot;[DEBUG] RAG functionality disabled - using only conversation history&quot;)&#10;&#10;        # Add user message to conversation&#10;        conversation.append({&#10;            &quot;role&quot;: &quot;user&quot;,&#10;            &quot;content&quot;: f&quot;{ctx.author}: {prompt}&quot;&#10;        })&#10;&#10;        # Send typing indicator while processing&#10;        async with ctx.channel.typing():&#10;            # Get response from Mistral&#10;            reply = await call_mistral(conversation)&#10;&#10;            if not reply.strip():&#10;                raise ValueError(&quot;Empty response from Mistral&quot;)&#10;&#10;            # Calculate elapsed time&#10;            elapsed_time = (time.perf_counter() - start_time) * 1000&#10;            print(f&quot;[DEBUG] Got response from Mistral (took {elapsed_time:.2f} ms)&quot;)&#10;&#10;            # Send the response&#10;            await ctx.send(reply)&#10;&#10;            # Add assistant response to conversation history&#10;            user_conversations[user_id].append({&#10;                &quot;role&quot;: &quot;user&quot;,&#10;                &quot;content&quot;: f&quot;{ctx.author}: {prompt}&quot;&#10;            })&#10;            user_conversations[user_id].append({&#10;                &quot;role&quot;: &quot;assistant&quot;,&#10;                &quot;content&quot;: reply&#10;            })&#10;&#10;            # Keep conversation history to a reasonable size (last 10 messages)&#10;            if len(user_conversations[user_id]) &gt; 12:  # system + 10 messages (5 exchanges)&#10;                # Keep the system message and the last 10 messages&#10;                user_conversations[user_id] = [user_conversations[user_id][0]] + user_conversations[user_id][-10:]&#10;&#10;            # Still store messages in memory for potential future use and stats&#10;            memory.store_message(prompt, str(ctx.author), role=&quot;user&quot;)&#10;            memory.store_message(reply, str(ctx.me), role=&quot;bot&quot;)&#10;            print(&quot;[DEBUG] Messages stored in memory (but not used for context)&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error in nai_command: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ An error occurred while processing the command.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;# Add a command to create a new conversation&#10;@bot.command(name=&quot;new&quot;)&#10;async def new_conversation(ctx):&#10;    &quot;&quot;&quot;Start a new conversation, forgetting previous context&quot;&quot;&quot;&#10;    user_id = str(ctx.author.id)&#10;&#10;    # Reset conversation for this user&#10;    user_conversations[user_id] = [{&#10;        &quot;role&quot;: &quot;system&quot;,&#10;        &quot;content&quot;: &quot;&quot;&quot;You're a Discord AI assistant. &#10;- Answer ONLY the current question&#10;- Be concise and helpful&#10;- No prefixes like &quot;Assistant:&quot; in response&quot;&quot;&quot;&#10;    }]&#10;&#10;    await ctx.send(&quot;Started a new conversation! Your previous conversation history has been cleared.&quot;)&#10;&#10;@bot.command(name=&quot;stats&quot;)&#10;async def stats_command(ctx):&#10;    &quot;&quot;&quot;Show conversation statistics&quot;&quot;&quot;&#10;    user_id = str(ctx.author.id)&#10;&#10;    stats_text = &quot;**Conversation Stats:**\n&quot;&#10;&#10;    # Get memory statistics&#10;    with sqlite3.connect(memory.db_path) as conn:&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;        total_messages = cursor.fetchone()[0]&#10;&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages WHERE role='user'&quot;)&#10;        user_messages = cursor.fetchone()[0]&#10;&#10;        cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages WHERE role='bot'&quot;)&#10;        bot_messages = cursor.fetchone()[0]&#10;&#10;    stats_text += f&quot; Total messages in memory: {total_messages}\n&quot;&#10;    stats_text += f&quot; User messages: {user_messages}\n&quot;&#10;    stats_text += f&quot; Bot messages: {bot_messages}\n&quot;&#10;&#10;    # Add conversation history stats&#10;    if user_id in user_conversations:&#10;        conv_len = len(user_conversations[user_id]) - 1  # Don't count system message&#10;        stats_text += f&quot; Your current conversation length: {conv_len} messages\n&quot;&#10;    else:&#10;        stats_text += &quot; No active conversation\n&quot;&#10;    &#10;    stats_text += &quot;\n*Note: RAG functionality is currently disabled*&quot;&#10;&#10;    await ctx.send(stats_text)&#10;&#10;bot.run(DISCORD_TOKEN)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bot/bot.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bot/bot.py" />
              <option name="originalContent" value="import os&#10;import json&#10;import discord&#10;from discord.ext import commands&#10;import httpx&#10;from dotenv import load_dotenv&#10;from memory import ConversationMemory&#10;&#10;load_dotenv()&#10;&#10;DISCORD_TOKEN = os.getenv(&quot;DISCORD_TOKEN&quot;)&#10;MISTRAL_API_KEY = os.getenv(&quot;MISTRAL_API_KEY&quot;)&#10;ALLOWED_CHANNEL_ID = int(os.getenv(&quot;ALLOWED_CHANNEL_ID&quot;))&#10;&#10;intents = discord.Intents.default()&#10;intents.message_content = True&#10;&#10;bot = commands.Bot(command_prefix=&quot;/&quot;, intents=intents)&#10;&#10;# Initialize memory system once&#10;memory = ConversationMemory()&#10;print(&quot;[DEBUG] Bot memory system initialized&quot;)&#10;&#10;async def call_mistral(prompt):&#10;    &quot;&quot;&quot;Simplified function to call Mistral API with a single user message&quot;&quot;&quot;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {MISTRAL_API_KEY}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;    }&#10;&#10;    # Send everything in a single user message&#10;    messages = [&#10;        {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}&#10;    ]&#10;&#10;    payload = {&#10;        &quot;model&quot;: &quot;mistral-small&quot;,&#10;        &quot;messages&quot;: messages,&#10;        &quot;temperature&quot;: 0.7&#10;    }&#10;&#10;    print(f&quot;[DEBUG] Sending request to Mistral API&quot;)&#10;    print(f&quot;[DEBUG] PROMPT TO MISTRAL:\n{prompt}...&quot;)&#10;&#10;    async with httpx.AsyncClient() as http_client:&#10;        response = await http_client.post(&#10;            &quot;https://api.mistral.ai/v1/chat/completions&quot;,&#10;            json=payload,&#10;            headers=headers,&#10;            timeout=15&#10;        )&#10;        response.raise_for_status()&#10;        data = response.json()&#10;        content = data[&quot;choices&quot;][0][&quot;message&quot;][&quot;content&quot;]&#10;        return content&#10;&#10;@bot.event&#10;async def on_ready():&#10;    print(f&quot;[READY] Logged in as {bot.user}&quot;)&#10;    channel = bot.get_channel(ALLOWED_CHANNEL_ID)&#10;    if channel:&#10;        await channel.send(&quot;Hello! I am online.&quot;)&#10;&#10;@bot.event&#10;async def on_message(message):&#10;    if message.author.bot or message.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;    await bot.process_commands(message)&#10;&#10;@bot.command(name=&quot;nai&quot;)&#10;async def nai_command(ctx, *, prompt: str = None):&#10;    if ctx.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;&#10;    if not prompt:&#10;        await ctx.send(&quot;⚠️ Please provide a prompt after /nai&quot;)&#10;        return&#10;&#10;    print(f&quot;[DEBUG] Processing /nai command from {ctx.author}: {prompt[:50]}...&quot;)&#10;&#10;    try:&#10;        # Get similar messages for context&#10;        similar_messages = memory.search_similar_messages(prompt, ignore_bot=False)&#10;        print(f&quot;[DEBUG] Found {len(similar_messages)} similar messages&quot;)&#10;&#10;        # Get recent messages for additional context&#10;        recent_messages = memory.get_recent_messages(10)&#10;        print(f&quot;[DEBUG] Retrieved {len(recent_messages)} recent messages&quot;)&#10;&#10;        # Build a single optimized prompt with instructions and context&#10;        full_prompt = f&quot;&quot;&quot;You're a Discord AI assistant. Answer ONLY the current question below.&#10;&#10;[INSTRUCTIONS]&#10;- Answer only the current question&#10;- Use past messages for context only&#10;- Be concise and helpful&#10;- No prefixes like &quot;Assistant:&quot; in response&#10;&#10;[RELEVANT MESSAGES]&#10;&quot;&quot;&quot;&#10;        # Add similar messages&#10;        if similar_messages:&#10;            for msg, similarity in similar_messages:&#10;                full_prompt += f&quot;{msg}\n&quot;&#10;&#10;        # Add recent messages&#10;        if recent_messages:&#10;            full_prompt += &quot;\n[RECENT MESSAGES]\n&quot;&#10;            for msg in recent_messages:&#10;                full_prompt += f&quot;{msg['author']} ({msg['role']}): {msg['content']}\n&quot;&#10;&#10;        # Add current question&#10;        full_prompt += f&quot;\n[CURRENT QUESTION]\n{ctx.author}: {prompt}\n&quot;&#10;&#10;        reply = None&#10;        async with ctx.channel.typing():&#10;            try:&#10;                reply = await call_mistral(full_prompt)&#10;                if not reply.strip():&#10;                    raise ValueError(&quot;Empty response from Mistral&quot;)&#10;                print(&quot;[DEBUG] Got response from Mistral&quot;)&#10;                await ctx.send(reply)&#10;            except Exception as e:&#10;                await ctx.send(&quot;⚠️ Error communicating with Mistral.&quot;)&#10;                print(f&quot;[DEBUG] Error calling Mistral: {str(e)}&quot;)&#10;&#10;        # Store messages in memory after sending the response&#10;        memory.store_message(prompt, str(ctx.author), role=&quot;user&quot;)&#10;        print(&quot;[DEBUG] User message stored in memory&quot;)&#10;&#10;        if reply:&#10;            memory.store_message(reply, str(ctx.me), role=&quot;bot&quot;)&#10;            print(&quot;[DEBUG] Bot reply stored in memory&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error in nai_command: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ An error occurred while processing the command.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;bot.run(DISCORD_TOKEN)&#10;" />
              <option name="updatedContent" value="import os&#10;import json&#10;import discord&#10;from discord.ext import commands&#10;import httpx&#10;from dotenv import load_dotenv&#10;from memory import ConversationMemory&#10;&#10;load_dotenv()&#10;&#10;DISCORD_TOKEN = os.getenv(&quot;DISCORD_TOKEN&quot;)&#10;MISTRAL_API_KEY = os.getenv(&quot;MISTRAL_API_KEY&quot;)&#10;ALLOWED_CHANNEL_ID = int(os.getenv(&quot;ALLOWED_CHANNEL_ID&quot;))&#10;&#10;intents = discord.Intents.default()&#10;intents.message_content = True&#10;&#10;bot = commands.Bot(command_prefix=&quot;/&quot;, intents=intents)&#10;&#10;# Initialize memory system once&#10;memory = ConversationMemory()&#10;print(&quot;[DEBUG] Bot memory system initialized&quot;)&#10;&#10;async def call_mistral(prompt):&#10;    &quot;&quot;&quot;Simplified function to call Mistral API with a single user message&quot;&quot;&quot;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {MISTRAL_API_KEY}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;    }&#10;&#10;    # Send everything in a single user message&#10;    messages = [&#10;        {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}&#10;    ]&#10;&#10;    payload = {&#10;        &quot;model&quot;: &quot;mistral-small&quot;,&#10;        &quot;messages&quot;: messages,&#10;        &quot;temperature&quot;: 0.7&#10;    }&#10;&#10;    print(f&quot;[DEBUG] Sending request to Mistral API&quot;)&#10;    print(f&quot;[DEBUG] PROMPT TO MISTRAL:\n{prompt}...&quot;)&#10;&#10;    async with httpx.AsyncClient() as http_client:&#10;        response = await http_client.post(&#10;            &quot;https://api.mistral.ai/v1/chat/completions&quot;,&#10;            json=payload,&#10;            headers=headers,&#10;            timeout=15&#10;        )&#10;        response.raise_for_status()&#10;        data = response.json()&#10;        content = data[&quot;choices&quot;][0][&quot;message&quot;][&quot;content&quot;]&#10;        return content&#10;&#10;@bot.event&#10;async def on_ready():&#10;    print(f&quot;[READY] Logged in as {bot.user}&quot;)&#10;    channel = bot.get_channel(ALLOWED_CHANNEL_ID)&#10;    if channel:&#10;        await channel.send(&quot;Hello! I am online.&quot;)&#10;&#10;@bot.event&#10;async def on_message(message):&#10;    if message.author.bot or message.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;    await bot.process_commands(message)&#10;&#10;@bot.command(name=&quot;nai&quot;)&#10;async def nai_command(ctx, *, prompt: str = None):&#10;    if ctx.channel.id != ALLOWED_CHANNEL_ID:&#10;        return&#10;&#10;    if not prompt:&#10;        await ctx.send(&quot;⚠️ Please provide a prompt after /nai&quot;)&#10;        return&#10;&#10;    print(f&quot;[DEBUG] Processing /nai command from {ctx.author}: {prompt[:50]}...&quot;)&#10;&#10;    try:&#10;        # Get similar messages for context&#10;        similar_messages = memory.search_similar_messages(prompt, ignore_bot=False)&#10;        print(f&quot;[DEBUG] Found {len(similar_messages)} similar messages&quot;)&#10;&#10;        # Get recent messages for additional context&#10;        recent_messages = memory.get_recent_messages(10)&#10;        print(f&quot;[DEBUG] Retrieved {len(recent_messages)} recent messages&quot;)&#10;&#10;        # Build a single optimized prompt with instructions and context&#10;        full_prompt = f&quot;&quot;&quot;You're a Discord AI assistant. Answer ONLY the current question below.&#10;&#10;[INSTRUCTIONS]&#10;- Answer only the current question&#10;- Use past messages for context only&#10;- Be concise and helpful&#10;- No prefixes like &quot;Assistant:&quot; in response&#10;&#10;[RELEVANT MESSAGES]&#10;&quot;&quot;&quot;&#10;        # Add similar messages&#10;        if similar_messages:&#10;            for msg, similarity in similar_messages:&#10;                full_prompt += f&quot;{msg}\n&quot;&#10;&#10;        # Add recent messages&#10;        if recent_messages:&#10;            full_prompt += &quot;\n[RECENT MESSAGES]\n&quot;&#10;            for msg in recent_messages:&#10;                full_prompt += f&quot;{msg['author']} ({msg['role']}): {msg['content']}\n&quot;&#10;&#10;        # Add current question&#10;        full_prompt += f&quot;\n[CURRENT QUESTION]\n{ctx.author}: {prompt}\n&quot;&#10;&#10;        reply = None&#10;        async with ctx.channel.typing():&#10;            try:&#10;                reply = await call_mistral(full_prompt)&#10;                if not reply.strip():&#10;                    raise ValueError(&quot;Empty response from Mistral&quot;)&#10;                print(&quot;[DEBUG] Got response from Mistral&quot;)&#10;                await ctx.send(reply)&#10;            except Exception as e:&#10;                await ctx.send(&quot;⚠️ Error communicating with Mistral.&quot;)&#10;                print(f&quot;[DEBUG] Error calling Mistral: {str(e)}&quot;)&#10;&#10;        # Store messages in memory after sending the response&#10;        memory.store_message(prompt, str(ctx.author), role=&quot;user&quot;)&#10;        print(&quot;[DEBUG] User message stored in memory&quot;)&#10;&#10;        if reply:&#10;            memory.store_message(reply, str(ctx.me), role=&quot;bot&quot;)&#10;            print(&quot;[DEBUG] Bot reply stored in memory&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;[DEBUG] Error in nai_command: {str(e)}&quot;)&#10;        await ctx.send(&quot;⚠️ An error occurred while processing the command.&quot;)&#10;&#10;    print(&quot;---&quot;)&#10;&#10;bot.run(DISCORD_TOKEN)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bot/memory.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bot/memory.py" />
              <option name="originalContent" value="import sqlite3&#10;import faiss&#10;import numpy as np&#10;from datetime import datetime&#10;from sentence_transformers import SentenceTransformer&#10;from typing import List, Tuple&#10;import time&#10;&#10;&#10;class ConversationMemory:&#10;    def __init__(self, db_path: str = &quot;conversations.db&quot;):&#10;        print(f&quot;[DEBUG] Initializing ConversationMemory with database: {db_path}&quot;)&#10;        self.db_path = db_path&#10;        self.model = SentenceTransformer('all-MiniLM-L6-v2')&#10;        self.index = None&#10;        self.initialize_db()&#10;        self.load_faiss_index()&#10;&#10;    def initialize_db(self):&#10;        print(&quot;[DEBUG] Initializing SQLite database...&quot;)&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            conn.execute(&quot;&quot;&quot;&#10;                CREATE TABLE IF NOT EXISTS messages&#10;                (id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                 content TEXT NOT NULL,&#10;                 author TEXT NOT NULL,&#10;                 role TEXT NOT NULL DEFAULT 'user',&#10;                 timestamp DATETIME NOT NULL,&#10;                 embedding BLOB)&#10;            &quot;&quot;&quot;)&#10;            conn.commit()&#10;&#10;            # Print schema for confirmation&#10;            cursor = conn.execute(&quot;PRAGMA table_info(messages)&quot;)&#10;            columns = [row[1] for row in cursor.fetchall()]&#10;            print(f&quot;[DEBUG] messages table columns: {columns}&quot;)&#10;&#10;        print(&quot;[DEBUG] Database initialization complete&quot;)&#10;&#10;    def store_message(self, content: str, author: str, role: str = &quot;user&quot;):&#10;        print(f&quot;[DEBUG] Storing message from {author} (role={role}): {content[:50]}...&quot;)&#10;        embedding = self.model.encode([content])[0]&#10;&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            cursor = conn.execute(&#10;                &quot;INSERT INTO messages (content, author, role, timestamp, embedding) VALUES (?, ?, ?, ?, ?)&quot;,&#10;                (content, author, role, datetime.now(), embedding.tobytes())&#10;            )&#10;            message_id = cursor.lastrowid&#10;            conn.commit()&#10;            print(f&quot;[DEBUG] Inserted message with ID: {message_id}&quot;)&#10;&#10;            cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;            count = cursor.fetchone()[0]&#10;            print(f&quot;[DEBUG] Total messages in database: {count}&quot;)&#10;&#10;        if self.index is None:&#10;            print(&quot;[DEBUG] Creating new FAISS index&quot;)&#10;            self.index = faiss.IndexFlatL2(embedding.shape[0])&#10;        self.index.add(embedding.reshape(1, -1))&#10;        print(f&quot;[DEBUG] FAISS index size: {self.index.ntotal}&quot;)&#10;&#10;    def search_similar_messages(self, query: str, k: int = 4, ignore_bot: bool = False) -&gt; List[Tuple[str, float]]:&#10;        print(f&quot;[DEBUG] Searching for messages similar to: {query[:50]}... (ignore_bot={ignore_bot})&quot;)&#10;        query_embedding = self.model.encode([query])[0]&#10;&#10;        if self.index is None or self.index.ntotal == 0:&#10;            print(&quot;[DEBUG] No messages in index to search&quot;)&#10;            return []&#10;&#10;        # Start timing the search&#10;        start_time = time.perf_counter()  # Start timing&#10;&#10;        # Get k+1 results since the query might be in the database&#10;        distances, indices = self.index.search(query_embedding.reshape(1, -1), min(k+1, self.index.ntotal))&#10;&#10;        elapsed = (time.perf_counter() - start_time) * 1000  # ms&#10;        print(f&quot;[DEBUG] FAISS search took {elapsed:.2f} ms&quot;)&#10;        print(f&quot;[DEBUG] FAISS found {len(indices[0])} results with indices: {indices[0]}&quot;)&#10;&#10;        results = []&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            for idx, distance in zip(indices[0], distances[0]):&#10;                if idx == -1:  # FAISS returns -1 for empty slots&#10;                    continue&#10;&#10;                # Fetch message and role&#10;                cursor = conn.execute(&#10;                    &quot;&quot;&quot;&#10;                    SELECT content, author, role, timestamp &#10;                    FROM messages &#10;                    LIMIT 1 OFFSET ?&#10;                    &quot;&quot;&quot;,&#10;                    (int(idx),)&#10;                )&#10;                row = cursor.fetchone()&#10;                if row:&#10;                    content, author, role, timestamp = row&#10;                    if ignore_bot and role == &quot;bot&quot;:&#10;                        continue&#10;                    similarity = 1.0 / (1.0 + float(distance))  # Convert distance to similarity score&#10;                    results.append((f&quot;{author} ({role}, {timestamp}): {content}&quot;, similarity))&#10;                    print(f&quot;[DEBUG] Found message at index {idx} with similarity {similarity:.3f} (role={role})&quot;)&#10;                else:&#10;                    print(f&quot;[DEBUG] No message found at index {idx}&quot;)&#10;&#10;        # Ensure we return only up to `k` results&#10;        results = results[:k]&#10;        print(f&quot;[DEBUG] Returning {len(results)} results&quot;)&#10;        return results&#10;&#10;    def load_faiss_index(self):&#10;        print(&quot;[DEBUG] Loading FAISS index from database...&quot;)&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;            count = cursor.fetchone()[0]&#10;            print(f&quot;[DEBUG] Found {count} messages in database&quot;)&#10;&#10;            cursor = conn.execute(&quot;SELECT embedding FROM messages&quot;)&#10;            embeddings = cursor.fetchall()&#10;&#10;            if embeddings:&#10;                embedding_size = len(np.frombuffer(embeddings[0][0], dtype=np.float32))&#10;                self.index = faiss.IndexFlatL2(embedding_size)&#10;                print(f&quot;[DEBUG] Created FAISS index with dimension {embedding_size}&quot;)&#10;&#10;                all_embeddings = np.vstack([&#10;                    np.frombuffer(emb[0], dtype=np.float32) for emb in embeddings&#10;                ])&#10;                self.index.add(all_embeddings)&#10;                print(f&quot;[DEBUG] Loaded {len(embeddings)} embeddings into FAISS index&quot;)&#10;            else:&#10;                print(&quot;[DEBUG] No existing embeddings found in database&quot;)&#10;" />
              <option name="updatedContent" value="import sqlite3&#10;import faiss&#10;import numpy as np&#10;from datetime import datetime&#10;from sentence_transformers import SentenceTransformer&#10;from typing import List, Tuple&#10;import time&#10;&#10;&#10;class ConversationMemory:&#10;    def __init__(self, db_path: str = &quot;conversations.db&quot;):&#10;        print(f&quot;[DEBUG] Initializing ConversationMemory with database: {db_path}&quot;)&#10;        self.db_path = db_path&#10;        self.model = SentenceTransformer('all-MiniLM-L6-v2')&#10;        self.index = None&#10;        self.initialize_db()&#10;        self.load_faiss_index()&#10;&#10;    def initialize_db(self):&#10;        print(&quot;[DEBUG] Initializing SQLite database...&quot;)&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            conn.execute(&quot;&quot;&quot;&#10;                CREATE TABLE IF NOT EXISTS messages&#10;                (id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                 content TEXT NOT NULL,&#10;                 author TEXT NOT NULL,&#10;                 role TEXT NOT NULL DEFAULT 'user',&#10;                 timestamp DATETIME NOT NULL,&#10;                 embedding BLOB)&#10;            &quot;&quot;&quot;)&#10;            conn.commit()&#10;&#10;            # Print schema for confirmation&#10;            cursor = conn.execute(&quot;PRAGMA table_info(messages)&quot;)&#10;            columns = [row[1] for row in cursor.fetchall()]&#10;            print(f&quot;[DEBUG] messages table columns: {columns}&quot;)&#10;&#10;        print(&quot;[DEBUG] Database initialization complete&quot;)&#10;&#10;    def store_message(self, content: str, author: str, role: str = &quot;user&quot;):&#10;        print(f&quot;[DEBUG] Storing message from {author} (role={role}): {content[:50]}...&quot;)&#10;        embedding = self.model.encode([content])[0]&#10;&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            cursor = conn.execute(&#10;                &quot;INSERT INTO messages (content, author, role, timestamp, embedding) VALUES (?, ?, ?, ?, ?)&quot;,&#10;                (content, author, role, datetime.now(), embedding.tobytes())&#10;            )&#10;            message_id = cursor.lastrowid&#10;            conn.commit()&#10;            print(f&quot;[DEBUG] Inserted message with ID: {message_id}&quot;)&#10;&#10;            cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;            count = cursor.fetchone()[0]&#10;            print(f&quot;[DEBUG] Total messages in database: {count}&quot;)&#10;&#10;        if self.index is None:&#10;            print(&quot;[DEBUG] Creating new FAISS index&quot;)&#10;            self.index = faiss.IndexFlatL2(embedding.shape[0])&#10;        self.index.add(embedding.reshape(1, -1))&#10;        print(f&quot;[DEBUG] FAISS index size: {self.index.ntotal}&quot;)&#10;&#10;    def search_similar_messages(self, query: str, k: int = 4, ignore_bot: bool = False) -&gt; List[Tuple[str, float]]:&#10;        print(f&quot;[DEBUG] Searching for messages similar to: {query[:50]}... (ignore_bot={ignore_bot})&quot;)&#10;        query_embedding = self.model.encode([query])[0]&#10;&#10;        if self.index is None or self.index.ntotal == 0:&#10;            print(&quot;[DEBUG] No messages in index to search&quot;)&#10;            return []&#10;&#10;        # Start timing the search&#10;        start_time = time.perf_counter()  # Start timing&#10;&#10;        # Get k+1 results since the query might be in the database&#10;        distances, indices = self.index.search(query_embedding.reshape(1, -1), min(k+1, self.index.ntotal))&#10;&#10;        elapsed = (time.perf_counter() - start_time) * 1000  # ms&#10;        print(f&quot;[DEBUG] FAISS search took {elapsed:.2f} ms&quot;)&#10;        print(f&quot;[DEBUG] FAISS found {len(indices[0])} results with indices: {indices[0]}&quot;)&#10;&#10;        results = []&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            for idx, distance in zip(indices[0], distances[0]):&#10;                if idx == -1:  # FAISS returns -1 for empty slots&#10;                    continue&#10;&#10;                # Fetch message and role&#10;                cursor = conn.execute(&#10;                    &quot;&quot;&quot;&#10;                    SELECT content, author, role, timestamp &#10;                    FROM messages &#10;                    LIMIT 1 OFFSET ?&#10;                    &quot;&quot;&quot;,&#10;                    (int(idx),)&#10;                )&#10;                row = cursor.fetchone()&#10;                if row:&#10;                    content, author, role, timestamp = row&#10;                    if ignore_bot and role == &quot;bot&quot;:&#10;                        continue&#10;                    similarity = 1.0 / (1.0 + float(distance))  # Convert distance to similarity score&#10;                    results.append((f&quot;{author} ({role}, {timestamp}): {content}&quot;, similarity))&#10;                    print(f&quot;[DEBUG] Found message at index {idx} with similarity {similarity:.3f} (role={role})&quot;)&#10;                else:&#10;                    print(f&quot;[DEBUG] No message found at index {idx}&quot;)&#10;&#10;        # Ensure we return only up to `k` results&#10;        results = results[:k]&#10;        print(f&quot;[DEBUG] Returning {len(results)} results&quot;)&#10;        return results&#10;&#10;    def load_faiss_index(self):&#10;        print(&quot;[DEBUG] Loading FAISS index from database...&quot;)&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            cursor = conn.execute(&quot;SELECT COUNT(*) FROM messages&quot;)&#10;            count = cursor.fetchone()[0]&#10;            print(f&quot;[DEBUG] Found {count} messages in database&quot;)&#10;&#10;            cursor = conn.execute(&quot;SELECT embedding FROM messages&quot;)&#10;            embeddings = cursor.fetchall()&#10;&#10;            if embeddings:&#10;                embedding_size = len(np.frombuffer(embeddings[0][0], dtype=np.float32))&#10;                self.index = faiss.IndexFlatL2(embedding_size)&#10;                print(f&quot;[DEBUG] Created FAISS index with dimension {embedding_size}&quot;)&#10;&#10;                all_embeddings = np.vstack([&#10;                    np.frombuffer(emb[0], dtype=np.float32) for emb in embeddings&#10;                ])&#10;                self.index.add(all_embeddings)&#10;                print(f&quot;[DEBUG] Loaded {len(embeddings)} embeddings into FAISS index&quot;)&#10;            else:&#10;                print(&quot;[DEBUG] No existing embeddings found in database&quot;)&#10;&#10;    def get_recent_messages(self, limit: int = 10) -&gt; List[dict]:&#10;        &quot;&quot;&quot;Retrieve the most recent messages from the database.&quot;&quot;&quot;&#10;        print(f&quot;[DEBUG] Retrieving {limit} most recent messages&quot;)&#10;        &#10;        results = []&#10;        with sqlite3.connect(self.db_path) as conn:&#10;            cursor = conn.execute(&#10;                &quot;&quot;&quot;&#10;                SELECT content, author, role, timestamp &#10;                FROM messages &#10;                ORDER BY id DESC &#10;                LIMIT ?&#10;                &quot;&quot;&quot;,&#10;                (limit,)&#10;            )&#10;            &#10;            rows = cursor.fetchall()&#10;            for row in rows:&#10;                content, author, role, timestamp = row&#10;                results.append({&#10;                    &quot;author&quot;: author,&#10;                    &quot;role&quot;: role,&#10;                    &quot;content&quot;: content,&#10;                    &quot;timestamp&quot;: timestamp&#10;                })&#10;            &#10;            print(f&quot;[DEBUG] Retrieved {len(results)} recent messages from database&quot;)&#10;        &#10;        # Return in chronological order (oldest first)&#10;        return list(reversed(results))" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>